# Concurrent Programming
[toc]

## 相关链接

[Java并发编程](https://juejin.cn/book/7116420171471781903/section/7116518259658063884?utm_source=post_pay_page)

## CPU的构成

![image-20230223004939098](https://image.kevinkda.cn/md/image-20230223004939098.png)

### 寄存器

​	寄存器中主要存储了从内存中加载的数据，寄存器的运行速度比内存快了好多个级别， 准确的说是从内存中将数据加载到L1，L2，L3缓存，再到寄存器中。而我们编写的程序在计算机底层转换为汇编语言之后，主要操作的对象就是寄存器。例如常见的mov和add指令

```assembly
mov eax, DWORD PTR i[rip]
add eax, 1
mov DWORD PRT i[rip], eax
```

​	寄存器按照存储的数据可分为两大类：存储内存地址类寄存器、存储非内存地址类寄存器。

 - 存储内存地址类寄存器
    - 程序计数器、基址寄存器、变址寄存器
- 存储非内存地址类寄存器
  - 累加寄存器、通用寄存器、标志寄存器

![image-20230223004907486](https://image.kevinkda.cn/md/image-20230223004927545.png)

### 控制器

​	控制器主要是起到一个辅助的功能，它可以帮助CPU做一些指令读取，结果写回等功能，同时它也能根据汇编指令的结果去操控一些计算机的硬件设备。

### 运算器

​	运算器是CPU内部最核心的用于做计算的模块，我们编写的程序在经过多步编译之后最终传达给到CPU的会是一段0和1组成的指令代码，这些指令在控制器的帮助下会将需要计算的数据放入到寄存器中，让运算器去计算。

###  时钟

​	主要是用于记录每次CPU计算的耗时，它的运算单位为ghz，1ghz = 10亿次/秒，通常ghz越高，表示CPU的运算效率越高。

### 寄存器和程序之间的关系

```java
public class CountDemo {

    public static void compareTest(int a, int b, int[] arr) {
        int t1 = countSum(a);
        int t2 = countSum(b);
        if (t1 > t2) {
            arr[0] = 1;
        } else {
            arr[1] = 1;
        }
    }

    //1～a的求和计算
    public static int countSum(int a) {
        int sum = 0;
        for (int i = 1; i <= a; i++) {
            sum += i;
        }
        return a;
    }

    public static void main(String[] args) {
        int a[] = {-1,-1};
        compareTest(1, 2, a); // ----- code_1
    }
    
}
```

​	这段程序在IDE开发完成之后，实际上会保存到磁盘当中

![image-20230223004927545](https://image.kevinkda.cn/md/image-20230223004907486.png)

​	接着如果要运行程序，可以输入Java指令去运行它，例如：javac和java指令。接下来磁盘中的程序会被读取到内存当中，并且进行相关的编译工作。期间涉及到多次编译，会在jvm层变成class字节码，然后再转换成汇编指令，最后才是机器码（这也是了解了将Java代码转成汇编指令才能认清它背后的原因了）。

![image-20230223011546110](https://image.kevinkda.cn/md/image-20230223011546110.png)

​	这些机器码存放的**地址**会被放到**程序计数器**的寄存器中，之后**控制器**会到根据程序计数器的地址去读取相关机器指令，并且将指令读取给**运算器**进行计算。当运行结束以后，**程序计数器的地址就会刷新，让控制器去加载新内存地址的指令给到运算器。**

![image-20230223011307830](https://image.kevinkda.cn/md/image-20230223011307830.png)

​	上方的CountDemo这段代码中虽然涉及到了求和计算、比较计算、函数调用三个功能，但是在实际过程中却涉及到了前面提到的六种寄存器。

​	首先main函数执行，**程序计数器的地址**会更新为main函数**入口的位置**，让控制器去加载其指令地址开始执行。接着在准备调用compareTest函数的时候，会有一条call指令将当前的程序计数器地址变更为子函数的入口，同理，在compareTest函数内部带哦用countSum函数也是会发送call指令。当子函数执行结束后，便执行一条return指令，返回原先执行代码位置的下一条指令位置。

​	countSum内部，会发现函数包含了求和累计的计算，这里面涉及到累加寄存器和标志寄存器的使用。**累加寄存器就是将sum的数值在累加寄存器中不断更新**。**而标志寄存器是用于判断是否满足跳出循环的逻辑**。

​	在for循环中编写的 i<=a; 这个逻辑，而计算机底层会通过做差的方式来判断是否满足该条件，也就是变成了 a - i >= 0; 的判断。通过a-i计算出来的结果会被记录到**标志寄存器**的某些个位上。

![image-20230223012739954](https://image.kevinkda.cn/md/image-20230223012739954.png)

​	**标志寄存器**可以理解为是一个巨大的bit数组，不同位置上的bit值代表了不同的涵义，当需要将计算的结果记录为负的话，只需要将bit[0]更新为1即可。

​	**变址寄存器**和**基址寄存器**，这两个寄存器主要的作用就是在数组进行元素定位的过程中会有所使用。

![image-20230223013045624](https://image.kevinkda.cn/md/image-20230223013045624.png)

​	CPU在对数组这类数据结构的内部元素进行定位的时候会通过基址寄存器的位置+变址寄存器的数值进行查询，变址寄存器的类似于数据的索引下标，通过一个相对偏差数值去对具体位置的定位。

​	通用寄存器可以理解为专门用于存储一些临时变量的公共区域，例如一些临时定义的数字值。



## 临界区

```java
public class IncrDemo {
    static int i = 0;
    
    public void incr(){
        i++;
    }
}
```

​	以上代码就是一段对 i 进行自增的操作，在单线程下程序的执行是正常的，但是多线程的情况下那么就很可能出现数据错乱的情况。当多个线程同时执行incr方法的时候，对于 i 的自增操作就是一个对于**临界区**的访问操作。

![image-20230312235257092](https://image.kevinkda.cn/md/image-20230312235257092.png)

​	临界区是计算机底层用于描述共享资源块的一项专业术语。当某一时刻同时有多个线程或者线程同时访问临界区的时候，每次只能允许一个线程访问成功，其他的线程则需要进入等待状态。为了实现这一效果， 操作系统需要确保对于临界区的资源每次访问都只能有一个请求抵达，于是乎有了**信号量**这个概念。



## 信号量



### 什么是信号量

​	信号量是一种设计思想， 它的本质可以理解为一个整形的数字(sem)，对于这个数字的访问，在具体实现上只提供两个原子操作，分别是

- P()：如果执行 sem - 1 之前，sem已经是0，则进入等待状态，否则进行正常扣减
- V()：如果执行 sem + 1 之前，sem已经是0，则执行完 sem + 1 后同时唤醒一个等待的P，否则就只是一个正常的 + 1 操作。

​    信号量的操作之所以具备原子性，这是和他的底层实现有关。操作系统底层提供了一种**原语**来对其进行操作，所谓**原语就是一种特别的程序段，这类程序要么一气呵成、要么不可被中断。**

​	下图中模拟了当一个请求访问到某一块临界区的时候，触发到预先程序中设定好的P操作，触发 sem - 1 操作，从而使得 sem = 0

![image-20230313004559263](https://image.kevinkda.cn/md/image-20230313004835701.png)

​	接下来，当有多个请求抵达临界区的时候，它们都会陆续触发P操作，但是此时 sem 值已经为0了，于是乎后续的请求就会被放到一条等待队列中。

​	随着之前在临界区的访问处理结束以后，会触发一次V操作，将 sem 的值 +1 ，然后会等待队列的队头通知一个处于等待状态的请求，让其进入临界区，接下来的操作以此类推。

​	很多高级语言的设计都是来自于操作系统的这些设计思路，发明信号量机制的工程师是荷兰人，P 和 V 分别代表荷兰用语， **V  verhoog  增加，P  prolaag  减少**。

​	

### 信号量在不同场景中的应用

- #### 实现多进程任务执行的先后顺序

​    A 进程的 method_3 需要在 B 进程执行 method_2 以后才运行，那么这个时候信号量运行实现就如下图所示。

![image-20230313004835701](https://image.kevinkda.cn/md/image-20230313010819512.png)

​	在执行 method_1 和 method_2 之前，先将 sem 设置为0，于是当 A 进程想要执行 method_3 之前，因为遇到了 sem = 0，于是调用 P 的时候处于阻塞状态。而此时需要借助 B 进程去发起 V 操作，才能让 A 线程继续执行。这样就能保证 A 进程每次执行 method_3 之前都是有 B 进程执行过一次 method_2 操作。

- #### 实现多进程间任务的前驱关系

  ​	进程 P1 中存在函数 S1 ，进程 P2 中存在函数 S2 ，进程 P3 中存在函数 S3 ，后续以此类推。现在需要确保各个进程中函数的执行顺序为 S1->S2->S3，S4->S5，S6，其中 S3 和 S4 之间没有优先级关系，S5 和 S6 之间也没有优先级关系，这种情况下其实也可以借助信号量的机制去实现。

![image-20230320015532327](https://image.kevinkda.cn/md/image-20230320015532327.png)

- #### 通过信号量来实现访问次数限制

  ​	对于某项资源访问，他只能同时允许有三个进程读取，当进程数量超过三个，则需要进入等待。这类场景很好理解并在实际中也经常出现，解决方式只需要将 sem 设置为 3 即可。

  ​	在出现了信号量机制之后，虽然能解决一部分简单的并发问题，但是在使用方式上依然是存在一些缺陷，于是对信号量做了一层**可读性更强的代码封装**，这个封装的结果就是**管程**。

### 管程

​	管程英文名为**monitor**，译为监视器，对于管程的理解，大致可以认为是基于对信号量做了一层封装，专门用于访问一些共享变量的函数，让调用方使用起来更加简单清晰，他的作用是一次只允许一个线程访问临界区，如果同时有多个访问，则其他访问挂起。

​	**信号量的应用主要是基于操作系统层面中，而管程的提出，则是用在了语言的场景中，它主要是专门针对于语言中的并发场景而设计的，从而简化了一些语言层面的实现逻辑。**例如Java内部对于并发模块的实现 wait()、notify()、notifyAll() 这些函数就是采用了管程的技术来控制。

#### 管程的组成

- 一把锁
- 0或者多个条件变量

**一把锁**：管程为了保证对于共享资源的访问一次只能有一个进程， 所以引入了锁的机制，没有抢到锁的进程则需要进入到**锁的等待队列进行等待**。

**0或者多个条件变量**：当进程获取到了锁的请求进入到临界区之后，有可能还需要做多个条件的判断，如果没有满足其中的某一条条件则需要进入**条件队列**（条件队列位于临界区外）中，若后续条件满足，则由其他进程进行唤醒。

![image-20230418162138098](https://image.kevinkda.cn/md/image-20230418162138098.png)

​	上文说过，管程内部需要有一把琐，因此对应的锁可以设计一套API去定义，以下是指令级别的设计与实现：

```assembly
Lock::Acquire() //等待锁可用，然后抢占
Lock::Release() //释放锁，唤醒等待队列中的线程
Wait() //释放当前锁，进入睡眠状态，
Signal() //当某个条件满足的时候，就会唤醒等待队列中线程
```